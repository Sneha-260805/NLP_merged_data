{"unnormalised": "एहि पाठ के मैथिली मे अनुवाद करू। केवल अनुवाद वापस करू; मूल पंक्ति विराम आ रिक्ति के सुरक्षित राखू।", "normalised": "ठिक अछि, हम व्यापक सामान्यीकरणक नियम आ \"Dr.\", \"Prof.\", आ \"Adv.\" क विशिष्ट प्रबंधन बुझैत छी। हम एहि आवश्यकताक अनुसार पाठ्य डेटा संसाधित करबाक लेल एकटा पायथन स्क्रिप्ट लागू करब।"}
{"unnormalised": "याद राखू कि चिकित्सा पेशेवर के लेल \"Dr.\" आ प्रोफेसर के लेल \"Prof.\" के प्रयोग करू। भारत मे कानूनी संदर्भ मे \"Adv.\" के प्रयोग वकील के लेल आम बात अछि।", "normalised": "स्क्रिप्ट प्रत्येक नियम कें केंना संबोधित करत, ओकर विवरण निम्नलिखित अछि, ओकर बाद पायथन कोड:"}
{"unnormalised": "", "normalised": "**कोर तर्क आ दृष्टिकोण:**"}
{"unnormalised": "", "normalised": "1.  **फाइल सिस्टम ट्रेवर्सल:** हम इनपुट निर्देशिकामे सभ फोल्डर आ फाइलमे पुनरावर्ती रूपसँ जाए लेल `os.walk` क उपयोग करब।"}
{"unnormalised": "", "normalised": "2.  **आउटपुट निर्देशिका मिररिंग:** इनपुटमे प्रत्येक फोल्डर लेल, हम `dataset_normalized` आउटपुट निर्देशिकामे एकटा संगत फोल्डर बनएब।"}
{"unnormalised": "", "normalised": "3.  **फाइल प्रोसेसिंग:**"}
{"unnormalised": "", "normalised": "    *   यदि कोनो फाइल `.txt` फाइल अछि, तँ एकर सामग्री पढ़ल जाएत, सामान्यीकृत कएल जाएत, आ फेर मिरर कएल आउटपुट फोल्डरमे एकटा नव `.txt` फाइलमे लिखल जाएत।"}
{"unnormalised": "", "normalised": "    *   यदि कोनो फाइल `.txt` फाइल नहि अछि, तँ एकरा बिना कोनो संशोधन केँ सीधे मिरर कएल आउटपुट फोल्डरमे कॉपी कएल जाएत।"}
{"unnormalised": "", "normalised": "4.  **सामान्यीकरण क्रम (सही आउटपुटक लेल महत्वपूर्ण):** सामान्यीकरण नियम लागू करबाक क्रम मायने रखैत अछि। हम आमतौर पर अधिक सामान्य नियमसँ पहिने अधिक विशिष्ट नियम लागू करब (उदाहरणक लेल, सामान्य संख्यासँ पहिने मुद्रा + संख्या + प्रत्यय, या सामान्य अक्षर-संख्यात्मक पैटर्नसँ पहिने विशिष्ट प्रतीक)।"}
{"unnormalised": "", "normalised": "    *   प्रतीक आ विशेष वर्ण।"}
{"unnormalised": "", "normalised": "    *   मुद्रा + संख्या + प्रत्यय।"}
{"unnormalised": "", "normalised": "    *   तिथि।"}
{"unnormalised": "", "normalised": "    *   संख्या (एकममे सेहो शामिल), मुदा एकमक विस्तार स्वयं बादमे आएत।"}
{"unnormalised": "", "normalised": "    *   संक्षिप्तीकरण।"}
{"unnormalised": "", "normalised": "    *   एकम।"}
{"unnormalised": "", "normalised": "    *   गणितीय संकेतन।"}
{"unnormalised": "", "normalised": "    *   \"Dr.\", \"Prof.\", \"Adv.\" जेहन विशेष उपसर्गकें संख्या या संक्षिप्तीकरण नियम द्वारा गलत व्याख्यासँ बचबाक लेल जल्दी या विशिष्ट regex कें साथ संभालल जाएत।"}
{"unnormalised": "", "normalised": "    *   सामान्य `/` हैंडलिंग।"}
{"unnormalised": "", "normalised": "    *   अंतिम चरणक रूपमे स्थान सामान्यीकरण।"}
{"unnormalised": "", "normalised": "**विस्तृत नियम कार्यान्वयन रणनीति:**"}
{"unnormalised": "", "normalised": "1.  **प्रतीक → कथित रूप:** हम सामान्य प्रतीक कें ओकर कथित रूप कें मैपिंग करए वाला एकटा शब्दकोश क उपयोग करब आ पाठ कें माध्यमसँ पुनरावृति करब, प्रतिस्थापन करब। नियमित अभिव्यक्तिक उपयोग ओहि प्रतीकक लेल कएल जाएत जँ ओ अलग-अलग संदर्भमे दिखाई देब। (उदाहरणक लेल, `+/-`)।"}
{"unnormalised": "", "normalised": "    *   `art/craft` -> `art or craft` (regex: `(\\b\\w+)\\/(\\w+\\b)`)"}
{"unnormalised": "", "normalised": "    *   `QA/Dev` -> `Q-A slash D-e-v` (मिश्रित मामला या संक्षिप्तीकरणक लेल regex `(\\b[A-Z0-9]+)\\/([A-Z0-9]+\\b)`)"}
{"unnormalised": "", "normalised": "    *   `2+2=4` कें गणितीय संकेतन नियम द्वारा संभालल जाएत।"}
{"unnormalised": "", "normalised": "    *   `$`, `~`, `*`, `#`, `@`, `&`, आदिकें सीधे मैप कएल जाएत।"}
{"unnormalised": "", "normalised": "2.  **संक्षिप्तीकरण → हाइफनेटेड अक्षर:**"}
{"unnormalised": "", "normalised": "    *   Regex: `\\b[A-Z]{2,}\\b` (दू या अधिक लगातार अपरकेस अक्षर, पूरा शब्दक रूपमे)। हमरा ध्यान राखए पड़त जे हम एकरा `Dr.`, `Prof.`, `Adv.` पर लागू नहि करी।"}
{"unnormalised": "", "normalised": "    *   `'-'.join(match.group())` सँ बदलू।"}
{"unnormalised": "", "normalised": "3.  **संख्या → कथित रूप:** ई जटिल अछि। हम सामान्य संख्या परिवर्तनक लेल `num2words` लाइब्रेरीक उपयोग करब, जँ अलग-अलग संदर्भकें संभालैत अछि। \"आधा किलोग्राम\" जेहन विशिष्ट मामलाक लेल, हम एकमक बाद `(\\d+)/(\\d+)\\s*(\\w+)` जेहन पैटर्न कें पहिचानबाक लेल regex क उपयोग करब, आ अंश पर `num2words` लागू करब या `1/2` कें \"आधा\" मे बदल देब।"}
{"unnormalised": "", "normalised": "    *   सामान्य संख्या: `num2words(number)`"}
{"unnormalised": "", "normalised": "    *   अंश: `1/2 kg` -> `half kilogram`, `3/4` -> `three divided by four` (गणित द्वारा संभालल गेल, मुदा तिथिसँ भ्रमित नहि होएकेँ ध्यान राखए पड़त)।"}
{"unnormalised": "", "normalised": "4.  **संख्यात्मक प्रत्यय → विस्तारित रूप:**"}
{"unnormalised": "", "normalised": "    *   Regex: `(\\d+)([KMBT])\\b`"}
{"unnormalised": "", "normalised": "    *   `K` कें `thousand`, `M` कें `million`, `B` कें `billion`, `T` कें `trillion` पर मैप करू।"}
{"unnormalised": "", "normalised": "    *   `num2words` क उपयोग करैत संख्या भाग कें रूपांतरित करू।"}
{"unnormalised": "", "normalised": "5.  **मुद्रा + संख्या + प्रत्यय:**"}
{"unnormalised": "", "normalised": "    *   Regex: `([$₹€£])(\\s*)(\\d+)([KMBT])?\\b`"}
{"unnormalised": "", "normalised": "    *   मुद्रा प्रतीक, संख्या, आ प्रत्यय रूपांतरित करू।"}
{"unnormalised": "", "normalised": "6.  **तिथि → प्राकृतिक कथित रूप:**"}
{"unnormalised": "", "normalised": "    *   `DD-MM-YYYY`, `DD/MM/YYYY`, `YYYY-MM-DD` क लेल Regex पैटर्न।"}
{"unnormalised": "", "normalised": "    *   पार्स् करबाक लेल `datetime.strptime` क उपयोग करू आ फेर क्रमवाचक संख्याक लेल कस्टम तर्क (उदाहरणक लेल, \"दसवाँ\", \"पहिला\") आ कथित वर्षक साथ `strftime` करू। `DD/MM/YYYY` कें संदिग्ध `DD/MM/YYYY` कें लेल डिफ़ॉल्ट मानि लेल।"}
{"unnormalised": "", "normalised": "7.  **एकम → कथित रूप:**"}
{"unnormalised": "", "normalised": "    *   `(\\d+)(\\s*)(cm|mm|m|km|g|kg|mg|ml|l|°C|...)` पता लगाबए कें लेल Regex"}
{"unnormalised": "", "normalised": "    *   एकमकें पूरा शब्दमे मैप करू (उदाहरणक लेल, `cm` कें `centimeter`, `°C` कें `degree celsius`)।"}
{"unnormalised": "", "normalised": "    *   पिछला संख्यामे संख्या रूपांतरण लागू करू।"}
{"unnormalised": "", "normalised": "8.  **गणितीय संकेतन → कथित रूप:** एकरा लेल regex क एकटा परिष्कृत सेट आ अधिक जटिल अभिव्यक्तिक लेल संभावित रूपसँ एकटा छोटहन पार्स् क आवश्यकता अछि।"}
{"unnormalised": "", "normalised": "    *   `x^2`: `x squared` (regex `(\\w)\\^2`)"}
{"unnormalised": "", "normalised": "    *   `x^3`: `x cubed` (regex `(\\w)\\^3`)"}
{"unnormalised": "", "normalised": "    *   `x^n`: `x to the power of n` (regex `(\\w)\\^(\\w+)`)"}
{"unnormalised": "", "normalised": "    *   `x_i`: `x sub i` (regex `(\\w)_(\\w+)`)"}
{"unnormalised": "", "normalised": "    *   `√x`: `square root of x` (regex `√(\\w+)`)"}
{"unnormalised": "", "normalised": "    *   `∫`: `integral`"}
{"unnormalised": "", "normalised": "    *   `Σ`: `summation`"}
{"unnormalised": "", "normalised": "    *   अंश: `3/4` -> `three divided by four` (regex: `(\\d+)\\/(\\d+)`, मुदा सुनिश्चित करैत जे ई कोनो तिथि नहि अछि)।"}
{"unnormalised": "", "normalised": "    *   प्रतीक: `≠`, `≤`, `≥` कें सामान्य प्रतीक प्रतिस्थापन द्वारा संभालल जाएत।"}
{"unnormalised": "", "normalised": "9.  **आउटपुट स्वरूप:**"}
{"unnormalised": "", "normalised": "    *   अंतमे स्थान कें सामान्य करू: `re.sub(r'\\s+', ' ', text).strip()`।"}
{"unnormalised": "", "normalised": "10. **फाइल हैंडलिंग:** `os.walk`, `os.makedirs`, `shutil.copy2`।"}
{"unnormalised": "", "normalised": "**विशिष्ट उपसर्ग हैंडलिंग:**"}
{"unnormalised": "", "normalised": "*   `Dr.`, `Prof.`, `Adv.` कें एहि सटीक स्ट्रिंग कें तलाश करए द्वारा संभालल जाएत, संभावित रूपसँ एकटा अवधि या स्थान बादमे, आ ओकरा संरक्षित करैत। ई सामान्य संक्षिप्तीकरण प्रसंस्करणसँ पहिने होएबाक चाही।"}
{"unnormalised": "", "normalised": "आउ पायथन स्क्रिप्ट बनाब शुरू करी।"}
{"unnormalised": "", "normalised": "```python"}
{"unnormalised": "", "normalised": "import os"}
{"unnormalised": "", "normalised": "import re"}
{"unnormalised": "", "normalised": "import shutil"}
{"unnormalised": "", "normalised": "from datetime import datetime"}
{"unnormalised": "", "normalised": "from num2words import num2words"}
{"unnormalised": "", "normalised": "import unicodedata # For handling unicode symbols"}
{"unnormalised": "", "normalised": "def ordinal_suffix(day):"}
{"unnormalised": "", "normalised": "    \"\"\"Returns the ordinal suffix for a number.\"\"\""}
{"unnormalised": "", "normalised": "    if 10 <= day % 100 <= 20:"}
{"unnormalised": "", "normalised": "        return 'th'"}
{"unnormalised": "", "normalised": "    else:"}
{"unnormalised": "", "normalised": "        return {1: 'st', 2: 'nd', 3: 'rd'}.get(day % 10, 'th')"}
{"unnormalised": "", "normalised": "def convert_number_to_words(number_str):"}
{"unnormalised": "", "normalised": "    \"\"\"Converts a number string to its spoken form, handling edge cases.\"\"\""}
{"unnormalised": "", "normalised": "    try:"}
{"unnormalised": "", "normalised": "        if '.' in number_str:"}
{"unnormalised": "", "normalised": "            # Handle decimals separately if num2words doesn't do it naturally for all cases"}
{"unnormalised": "", "normalised": "            integer_part, decimal_part = number_str.split('.')"}
{"unnormalised": "", "normalised": "            integer_words = num2words(int(integer_part))"}
{"unnormalised": "", "normalised": "            decimal_words = 'point ' + ' '.join(num2words(int(d)) for d in decimal_part)"}
{"unnormalised": "", "normalised": "            return f\"{integer_words} {decimal_words}\""}
{"unnormalised": "", "normalised": "        else:"}
{"unnormalised": "", "normalised": "            return num2words(int(number_str))"}
{"unnormalised": "", "normalised": "    except ValueError:"}
{"unnormalised": "", "normalised": "        return number_str # Return original if conversion fails"}
{"unnormalised": "", "normalised": "def normalize_text(text):"}
{"unnormalised": "", "normalised": "    \"\"\""}
{"unnormalised": "", "normalised": "    Applies all normalization rules to the input text."}
{"unnormalised": "", "normalised": "    \"\"\""}
{"unnormalised": "", "normalised": "    # --- 0. Special Prefix Handling (Dr., Prof., Adv.) ---"}
{"unnormalised": "", "normalised": "    # These are handled by keeping them as is, they should not be treated as acronyms."}
{"unnormalised": "", "normalised": "    # No explicit replacement needed, just ensures other rules don't modify them."}
{"unnormalised": "", "normalised": "    # --- 1. Symbols → Spoken form ---"}
{"unnormalised": "", "normalised": "    # More specific symbol replacements first"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\+/-', 'plus or minus', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'!=', 'not equal to', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'<=', 'less than or equal to', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'>=', 'greater than or equal to', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'==', 'equals', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'->', 'maps to', text) # Common in math/programming context"}
{"unnormalised": "", "normalised": "    symbol_map = {"}
{"unnormalised": "", "normalised": "        '#': 'hash',"}
{"unnormalised": "", "normalised": "        '@': 'at',"}
{"unnormalised": "", "normalised": "        '&': 'and',"}
{"unnormalised": "", "normalised": "        '*': 'asterisk',"}
{"unnormalised": "", "normalised": "        '~': 'approximately',"}
{"unnormalised": "", "normalised": "        '≠': 'not equal to',"}
{"unnormalised": "", "normalised": "        '≤': 'less than or equal to',"}
{"unnormalised": "", "normalised": "        '≥': 'greater than or equal to',"}
{"unnormalised": "", "normalised": "        '∫': 'integral',"}
{"unnormalised": "", "normalised": "        '∑': 'summation',"}
{"unnormalised": "", "normalised": "        'π': 'pi',"}
{"unnormalised": "", "normalised": "        '√': 'square root of',"}
{"unnormalised": "", "normalised": "        '%': 'percent', # After ~ approximately, before general numbers"}
{"unnormalised": "", "normalised": "        '°': 'degree', # Before general numbers"}
{"unnormalised": "", "normalised": "        '€': 'euro',"}
{"unnormalised": "", "normalised": "        '£': 'pound',"}
{"unnormalised": "", "normalised": "    }"}
{"unnormalised": "", "normalised": "    # Sort keys by length in descending order to avoid partial matches (e.g., '≠' before '≠')"}
{"unnormalised": "", "normalised": "    for symbol, spoken_form in sorted(symbol_map.items(), key=lambda item: len(item[0]), reverse=True):"}
{"unnormalised": "", "normalised": "        text = text.replace(symbol, spoken_form)"}
{"unnormalised": "", "normalised": "    # Handling '/'"}
{"unnormalised": "", "normalised": "    # Priority:"}
{"unnormalised": "", "normalised": "    # 1. Divided by (between numbers/math)"}
{"unnormalised": "", "normalised": "    # 2. Or (between words)"}
{"unnormalised": "", "normalised": "    # 3. Slash (mixed cases, abbreviations, remaining)"}
{"unnormalised": "", "normalised": "    # 1. Fractions or division in math: 3/4 -> three divided by four, 1/2 -> one divided by two"}
{"unnormalised": "", "normalised": "    # This needs to be robust, ensuring it's not a date."}
{"unnormalised": "", "normalised": "    # Specific for 1/2 as \"half\" when followed by a unit (Rule 3/7 interplay)"}
{"unnormalised": "", "normalised": "    def replace_fraction_with_unit(match):"}
{"unnormalised": "", "normalised": "        num_str = match.group(1)"}
{"unnormalised": "", "normalised": "        denom_str = match.group(2)"}
{"unnormalised": "", "normalised": "        unit = match.group(3) if match.group(3) else ''"}
{"unnormalised": "", "normalised": "        if num_str == '1' and denom_str == '2':"}
{"unnormalised": "", "normalised": "            return f\"half {unit}\""}
{"unnormalised": "", "normalised": "        else:"}
{"unnormalised": "", "normalised": "            return f\"{convert_number_to_words(num_str)} divided by {convert_number_to_words(denom_str)} {unit}\".strip()"}
{"unnormalised": "", "normalised": "    # Pattern for X/Y unit, e.g., 1/2 kg, 3/4 meter"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b(\\d+)/(\\d+)\\s*(cm|mm|m|km|g|kg|mg|ml|l|C|F|K|hour|day|week|month|year)s?\\b',"}
{"unnormalised": "", "normalised": "                  replace_fraction_with_unit, text, flags=re.IGNORECASE)"}
{"unnormalised": "", "normalised": "    # Pattern for X/Y without a specific unit, e.g., 3/4"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b(\\d+)/(\\d+)\\b',"}
{"unnormalised": "", "normalised": "                  lambda m: f\"{convert_number_to_words(m.group(1))} divided by {convert_number_to_words(m.group(2))}\","}
{"unnormalised": "", "normalised": "                  text)"}
{"unnormalised": "", "normalised": "    # 2. \"or\" between words (e.g., art/craft)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'(\\b\\w+)\\/(\\w+\\b)', r'\\1 or \\2', text)"}
{"unnormalised": "", "normalised": "    # 3. \"slash\" for mixed cases or abbreviations (e.g., QA/Dev, R/D)"}
{"unnormalised": "", "normalised": "    # This also catches any remaining slashes that aren't dates or fractions"}
{"unnormalised": "", "normalised": "    text = re.sub(r'([A-Za-z0-9]+)\\/([A-Za-z0-9]+)', r'\\1 slash \\2', text)"}
{"unnormalised": "", "normalised": "    # --- 2. Acronyms → Hyphenated letters ---"}
{"unnormalised": "", "normalised": "    # Exclude Dr., Prof., Adv. and common currency codes (e.g., USD, EUR, INR)"}
{"unnormalised": "", "normalised": "    # Also exclude single letters or numbers that might be part of an expression, and units."}
{"unnormalised": "", "normalised": "    # This regex is tricky. Let's try to match sequences of uppercase letters."}
{"unnormalised": "", "normalised": "    # Lookbehind for a word boundary, lookahead for a word boundary."}
{"unnormalised": "", "normalised": "    # Exclude common pre-defined terms."}
{"unnormalised": "", "normalised": "    excluded_acronyms = {'DR', 'PROF', 'ADV', 'USD', 'EUR', 'GBP', 'INR', 'K', 'M', 'B', 'T'}"}
{"unnormalised": "", "normalised": "    def replace_acronym(match):"}
{"unnormalised": "", "normalised": "        acronym = match.group(0)"}
{"unnormalised": "", "normalised": "        if acronym in excluded_acronyms:"}
{"unnormalised": "", "normalised": "            return acronym"}
{"unnormalised": "", "normalised": "        # Check if it's potentially a unit like 'KG', 'CM' etc. (already handled by units rule later)"}
{"unnormalised": "", "normalised": "        if len(acronym) <= 3 and acronym.lower() in ['cm', 'mm', 'm', 'km', 'g', 'kg', 'mg', 'ml', 'l', 'c', 'f', 'k']:"}
{"unnormalised": "", "normalised": "            return acronym # Let unit rule handle it"}
{"unnormalised": "", "normalised": "        return '-'.join(list(acronym))"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b[A-Z]{2,}\\b', replace_acronym, text)"}
{"unnormalised": "", "normalised": "    # --- 6. Dates → Natural spoken form ---"}
{"unnormalised": "", "normalised": "    # Prioritize YYYY-MM-DD"}
{"unnormalised": "", "normalised": "    def replace_date(match):"}
{"unnormalised": "", "normalised": "        try:"}
{"unnormalised": "", "normalised": "            date_obj = datetime.strptime(match.group(0), '%Y-%m-%d')"}
{"unnormalised": "", "normalised": "            day = date_obj.day"}
{"unnormalised": "", "normalised": "            month = date_obj.strftime('%B').lower()"}
{"unnormalised": "", "normalised": "            year = num2words(date_obj.year)"}
{"unnormalised": "", "normalised": "            return f\"{num2words(day, to='ordinal')} {month} {year}\""}
{"unnormalised": "", "normalised": "        except ValueError:"}
{"unnormalised": "", "normalised": "            return match.group(0) # Return original if parsing fails"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b\\d{4}-\\d{2}-\\d{2}\\b', replace_date, text)"}
{"unnormalised": "", "normalised": "    # Prioritize DD-MM-YYYY or DD/MM/YYYY (assuming DD/MM/YYYY when ambiguous)"}
{"unnormalised": "", "normalised": "    def replace_date_ambiguous(match):"}
{"unnormalised": "", "normalised": "        try:"}
{"unnormalised": "", "normalised": "            # Try DD/MM/YYYY first"}
{"unnormalised": "", "normalised": "            date_obj = datetime.strptime(match.group(0), '%d/%m/%Y')"}
{"unnormalised": "", "normalised": "        except ValueError:"}
{"unnormalised": "", "normalised": "            try:"}
{"unnormalised": "", "normalised": "                # Then try DD-MM-YYYY"}
{"unnormalised": "", "normalised": "                date_obj = datetime.strptime(match.group(0), '%d-%m-%Y')"}
{"unnormalised": "", "normalised": "            except ValueError:"}
{"unnormalised": "", "normalised": "                return match.group(0) # Return original if parsing fails"}
{"unnormalised": "", "normalised": "        day = date_obj.day"}
{"unnormalised": "", "normalised": "        month = date_obj.strftime('%B').lower()"}
{"unnormalised": "", "normalised": "        year = num2words(date_obj.year)"}
{"unnormalised": "", "normalised": "        return f\"{num2words(day, to='ordinal')} {month} {year}\""}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b\\d{2}[-/]\\d{2}[-/]\\d{4}\\b', replace_date_ambiguous, text)"}
{"unnormalised": "", "normalised": "    # --- 5. Currency + Number + Suffix ---"}
{"unnormalised": "", "normalised": "    # This must come before general numeric suffix and general number conversion."}
{"unnormalised": "", "normalised": "    def replace_currency_suffix(match):"}
{"unnormalised": "", "normalised": "        currency_symbol = match.group(1)"}
{"unnormalised": "", "normalised": "        number_str = match.group(3)"}
{"unnormalised": "", "normalised": "        suffix = match.group(4)"}
{"unnormalised": "", "normalised": "        "}
{"unnormalised": "", "normalised": "        currency_name = ''"}
{"unnormalised": "", "normalised": "        if currency_symbol == '$':"}
{"unnormalised": "", "normalised": "            currency_name = 'dollar'"}
{"unnormalised": "", "normalised": "        elif currency_symbol == '₹':"}
{"unnormalised": "", "normalised": "            currency_name = 'rupee'"}
{"unnormalised": "", "normalised": "        # Add other currencies if needed"}
{"unnormalised": "", "normalised": "        spoken_number = convert_number_to_words(number_str)"}
{"unnormalised": "", "normalised": "        if suffix:"}
{"unnormalised": "", "normalised": "            suffix_map = {'K': 'thousand', 'M': 'million', 'B': 'billion', 'T': 'trillion'}"}
{"unnormalised": "", "normalised": "            return f\"{currency_name} {spoken_number} {suffix_map[suffix]}\""}
{"unnormalised": "", "normalised": "        else:"}
{"unnormalised": "", "normalised": "            return f\"{currency_name} {spoken_number}\""}
{"unnormalised": "", "normalised": "    text = re.sub(r'([$₹€£])(\\s*)(\\d+)([KMBT])?\\b', replace_currency_suffix, text)"}
{"unnormalised": "", "normalised": "    # --- 4. Numeric suffixes → Expanded form ---"}
{"unnormalised": "", "normalised": "    # This must come before general number conversion."}
{"unnormalised": "", "normalised": "    def replace_numeric_suffix(match):"}
{"unnormalised": "", "normalised": "        number_str = match.group(1)"}
{"unnormalised": "", "normalised": "        suffix = match.group(2)"}
{"unnormalised": "", "normalised": "        spoken_number = convert_number_to_words(number_str)"}
{"unnormalised": "", "normalised": "        "}
{"unnormalised": "", "normalised": "        suffix_map = {'K': 'thousand', 'M': 'million', 'B': 'billion', 'T': 'trillion'}"}
{"unnormalised": "", "normalised": "        return f\"{spoken_number} {suffix_map[suffix]}\""}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b(\\d+)([KMBT])\\b', replace_numeric_suffix, text)"}
{"unnormalised": "", "normalised": "    # --- 7. Units → Spoken form ---"}
{"unnormalised": "", "normalised": "    # This must come before general number conversion."}
{"unnormalised": "", "normalised": "    unit_map = {"}
{"unnormalised": "", "normalised": "        'cm': 'centimeter', 'mm': 'millimeter', 'm': 'meter', 'km': 'kilometer',"}
{"unnormalised": "", "normalised": "        'g': 'gram', 'kg': 'kilogram', 'mg': 'milligram',"}
{"unnormalised": "", "normalised": "        'ml': 'milliliter', 'l': 'liter',"}
{"unnormalised": "", "normalised": "        'C': 'celsius', 'F': 'fahrenheit', 'K': 'kelvin', # For degree units"}
{"unnormalised": "", "normalised": "        'hrs': 'hours', 'hr': 'hour',"}
{"unnormalised": "", "normalised": "        'min': 'minute', 'mins': 'minutes',"}
{"unnormalised": "", "normalised": "        'sec': 'second', 'secs': 'seconds',"}
{"unnormalised": "", "normalised": "        'volt': 'volt', 'volts': 'volts', 'v': 'volt',"}
{"unnormalised": "", "normalised": "        'amp': 'ampere', 'amps': 'amperes', 'a': 'ampere',"}
{"unnormalised": "", "normalised": "        'watt': 'watt', 'watts': 'watts', 'w': 'watt',"}
{"unnormalised": "", "normalised": "        'hz': 'hertz', 'khz': 'kilohertz', 'mhz': 'megahertz', 'ghz': 'gigahertz'"}
{"unnormalised": "", "normalised": "    }"}
{"unnormalised": "", "normalised": "    def replace_unit(match):"}
{"unnormalised": "", "normalised": "        number_str = match.group(1)"}
{"unnormalised": "", "normalised": "        unit = match.group(2).lower()"}
{"unnormalised": "", "normalised": "        spoken_number = convert_number_to_words(number_str)"}
{"unnormalised": "", "normalised": "        spoken_unit = unit_map.get(unit, unit)"}
{"unnormalised": "", "normalised": "        # Handle plurals for units"}
{"unnormalised": "", "normalised": "        if int(number_str) > 1 and not spoken_unit.endswith('s') and spoken_unit not in ['celsius', 'fahrenheit', 'kelvin']:"}
{"unnormalised": "", "normalised": "            spoken_unit += 's'"}
{"unnormalised": "", "normalised": "        elif int(number_str) == 1 and spoken_unit.endswith('s') and spoken_unit not in ['celsius', 'fahrenheit', 'kelvin']:"}
{"unnormalised": "", "normalised": "            spoken_unit = spoken_unit[:-1] # Remove 's' if number is 1 and unit is plural"}
{"unnormalised": "", "normalised": "        return f\"{spoken_number} {spoken_unit}\""}
{"unnormalised": "", "normalised": "    # Pattern for numbers directly followed by a unit (e.g., 10cm, 5kg)"}
{"unnormalised": "", "normalised": "    # Using \\b for units to avoid partial matches (e.g., 'm' in 'meter')"}
{"unnormalised": "", "normalised": "    unit_pattern = r'\\b(\\d+(?:\\.\\d+)?)\\s*(%s)\\b' % '|'.join(re.escape(u) for u in unit_map.keys())"}
{"unnormalised": "", "normalised": "    text = re.sub(unit_pattern, replace_unit, text, flags=re.IGNORECASE)"}
{"unnormalised": "", "normalised": "    # Handle degrees Celsius/Fahrenheit specifically, often written as 25°C"}
{"unnormalised": "", "normalised": "    def replace_degree_unit(match):"}
{"unnormalised": "", "normalised": "        number_str = match.group(1)"}
{"unnormalised": "", "normalised": "        unit = match.group(2).upper() # 'C', 'F'"}
{"unnormalised": "", "normalised": "        spoken_number = convert_number_to_words(number_str)"}
{"unnormalised": "", "normalised": "        unit_name = 'celsius' if unit == 'C' else 'fahrenheit' if unit == 'F' else 'kelvin' if unit == 'K' else ''"}
{"unnormalised": "", "normalised": "        return f\"{spoken_number} degree {unit_name}\""}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b(\\d+(?:\\.\\d+)?)\\s*degree\\s*([CFK])\\b', replace_degree_unit, text, flags=re.IGNORECASE) # After 'degree' symbol is replaced"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b(\\d+(?:\\.\\d+)?)\\s*degree\\s*(celsius|fahrenheit|kelvin)\\b', lambda m: f\"{convert_number_to_words(m.group(1))} degree {m.group(2)}\", text, flags=re.IGNORECASE)"}
{"unnormalised": "", "normalised": "    # --- 3. Numbers → Spoken form (general) ---"}
{"unnormalised": "", "normalised": "    # Apply to any remaining standalone numbers. This should be late."}
{"unnormalised": "", "normalised": "    # Exclude numbers that are part of file names or mixed alphanumeric strings that don't look like numbers."}
{"unnormalised": "", "normalised": "    def replace_general_number(match):"}
{"unnormalised": "", "normalised": "        number_str = match.group(0)"}
{"unnormalised": "", "normalised": "        # Avoid converting numbers that are part of other identifiers (e.g., H2O, ID123)"}
{"unnormalised": "", "normalised": "        if re.match(r'^[A-Za-z]+$', number_str): # If it's pure alphabet, ignore"}
{"unnormalised": "", "normalised": "            return number_str"}
{"unnormalised": "", "normalised": "        "}
{"unnormalised": "", "normalised": "        # Avoid converting if it's a floating point number with only zero after decimal and num2words gives full stop"}
{"unnormalised": "", "normalised": "        if '.' in number_str and float(number_str) == int(float(number_str)):"}
{"unnormalised": "", "normalised": "            return convert_number_to_words(str(int(float(number_str))))"}
{"unnormalised": "", "normalised": "            "}
{"unnormalised": "", "normalised": "        return convert_number_to_words(number_str)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b\\d+(?:\\.\\d+)?\\b', replace_general_number, text)"}
{"unnormalised": "", "normalised": "    # --- 8. Mathematical notation → Spoken form ---"}
{"unnormalised": "", "normalised": "    # Ensure this happens after general symbol/number conversions to avoid conflicts"}
{"unnormalised": "", "normalised": "    text = re.sub(r'(\\w)\\^2', r'\\1 squared', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'(\\w)\\^3', r'\\1 cubed', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'(\\w)\\^(\\w+)', r'\\1 to the power of \\2', text) # General power"}
{"unnormalised": "", "normalised": "    text = re.sub(r'(\\w)_(\\w+)', r'\\1 sub \\2', text) # Subscript"}
{"unnormalised": "", "normalised": "    text = re.sub(r'summation\\s*x\\s*sub\\s*i', 'summation of x sub i', text) # Common summation form"}
{"unnormalised": "", "normalised": "    text = re.sub(r'integral\\s*(\\d+)\\s*to\\s*(\\d+)\\s*of\\s*(\\w)\\s*d\\s*(\\w)',"}
{"unnormalised": "", "normalised": "                  lambda m: f\"integral from {convert_number_to_words(m.group(1))} to {convert_number_to_words(m.group(2))} of {m.group(3)} d {m.group(4)}\","}
{"unnormalised": "", "normalised": "                  text) # Specific integral form ∫ 0→1 x dx"}
{"unnormalised": "", "normalised": "    text = re.sub(r'integral\\s*(\\w)\\s*d\\s*(\\w)', r'integral of \\1 d \\2', text) # General integral form ∫ x dx"}
{"unnormalised": "", "normalised": "    # --- Final Space Normalization ---"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\s+', ' ', text).strip()"}
{"unnormalised": "", "normalised": "    return text"}
{"unnormalised": "", "normalised": "def process_folder(input_folder, output_folder):"}
{"unnormalised": "", "normalised": "    \"\"\""}
{"unnormalised": "", "normalised": "    Walks through the input folder, normalizes .txt files, and copies others."}
{"unnormalised": "", "normalised": "    \"\"\""}
{"unnormalised": "", "normalised": "    os.makedirs(output_folder, exist_ok=True)"}
{"unnormalised": "", "normalised": "    unnormalized_txt_files = []"}
{"unnormalised": "", "normalised": "    for root, dirs, files in os.walk(input_folder):"}
{"unnormalised": "", "normalised": "        relative_path = os.path.relpath(root, input_folder)"}
{"unnormalised": "", "normalised": "        current_output_dir = os.path.join(output_folder, relative_path)"}
{"unnormalised": "", "normalised": "        os.makedirs(current_output_dir, exist_ok=True)"}
{"unnormalised": "", "normalised": "        for file_name in files:"}
{"unnormalised": "", "normalised": "            input_file_path = os.path.join(root, file_name)"}
{"unnormalised": "", "normalised": "            output_file_path = os.path.join(current_output_dir, file_name)"}
{"unnormalised": "", "normalised": "            if file_name.lower().endswith('.txt'):"}
{"unnormalised": "", "normalised": "                try:"}
{"unnormalised": "", "normalised": "                    with open(input_file_path, 'r', encoding='utf-8') as f_in:"}
{"unnormalised": "", "normalised": "                        content = f_in.read()"}
{"unnormalised": "", "normalised": "                    "}
{"unnormalised": "", "normalised": "                    normalized_content = normalize_text(content)"}
{"unnormalised": "", "normalised": "                    with open(output_file_path, 'w', encoding='utf-8') as f_out:"}
{"unnormalised": "", "normalised": "                        f_out.write(normalized_content)"}
{"unnormalised": "", "normalised": "                except Exception as e:"}
{"unnormalised": "", "normalised": "                    print(f\"Error processing {input_file_path}: {e}\")"}
{"unnormalised": "", "normalised": "                    unnormalized_txt_files.append(input_file_path)"}
{"unnormalised": "", "normalised": "                    # If error, copy the original file to output"}
{"unnormalised": "", "normalised": "                    shutil.copy2(input_file_path, output_file_path)"}
{"unnormalised": "", "normalised": "            else:"}
{"unnormalised": "", "normalised": "                shutil.copy2(input_file_path, output_file_path)"}
{"unnormalised": "", "normalised": "    "}
{"unnormalised": "", "normalised": "    if unnormalized_txt_files:"}
{"unnormalised": "", "normalised": "        print(\"\\n--- List of .txt files that could not be normalized (original copied instead) ---\")"}
{"unnormalised": "", "normalised": "        for f in unnormalized_txt_files:"}
{"unnormalised": "", "normalised": "            print(f)"}
{"unnormalised": "", "normalised": "if __name__ == \"__main__\":"}
{"unnormalised": "", "normalised": "    # Example usage:"}
{"unnormalised": "", "normalised": "    # Create a dummy dataset structure for testing"}
{"unnormalised": "", "normalised": "    if not os.path.exists(\"dataset\"):"}
{"unnormalised": "", "normalised": "        os.makedirs(\"dataset/subfolder1\", exist_ok=True)"}
{"unnormalised": "", "normalised": "        os.makedirs(\"dataset/subfolder2\", exist_ok=True)"}
{"unnormalised": "", "normalised": "        with open(\"dataset/test1.txt\", \"w\", encoding=\"utf-8\") as f:"}
{"unnormalised": "", "normalised": "            f.write(\"The price is $20B. NASA launched in 1958. Approx ~5% gain.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"Today's date is 10/09/2024. Dr. Smith works for the U.S.A. government.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"The temperature is 25°C. Water boiled at 100°C. Total 5km run.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"The equation is 2+2=4. Area is πr^2. Sum is Σ x_i. Consider x^2 and x^3. Also x^n.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"The fraction is 3/4. We need 1/2 kg of sugar. The report covers QA/Dev and art/craft. GDP growth is strong. Adv. Ram is here.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"Math: ∫ x^2 dx. Or ∫ 0→1 x dx. If x != y, then x <= z or z >= x. He runs 100M dash.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"He ran 10km in 45 min. His speed was 100km/hr. The battery is 12V and 50A.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"Product IDs: PROD123, PROD456.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"₹500M was invested. The value is 99. The number is 7.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"This has a decimal 12.5 kg. A total of 1.0 M people. Test 1.0 kg and 1.00 kg.\\n\")"}
{"unnormalised": "", "normalised": "        with open(\"dataset/subfolder1/test2.txt\", \"w\", encoding=\"utf-8\") as f:"}
{"unnormalised": "", "normalised": "            f.write(\"Project Alpha started 2023-12-01. Prof. Jones gave a lecture on ∫ x^n dx.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"He spent 2.5 hrs studying. The data is 1.2M records. He earns 50K per month.\\n\")"}
{"unnormalised": "", "normalised": "        with open(\"dataset/subfolder2/image.jpg\", \"w\", encoding=\"utf-8\") as f:"}
{"unnormalised": "", "normalised": "            f.write(\"This is not a text file.\") # Dummy content for non-txt file"}
{"unnormalised": "", "normalised": "        with open(\"dataset/subfolder2/another.txt\", \"w\", encoding=\"utf-8\") as f:"}
{"unnormalised": "", "normalised": "            f.write(\"Special characters: ≠, ≤, ≥. Test approximately five percent ~5%. Hash #tag. At @user. And & more.\")"}
{"unnormalised": "", "normalised": "    input_data_folder = \"dataset\""}
{"unnormalised": "", "normalised": "    output_normalized_folder = \"dataset_normalized\""}
{"unnormalised": "", "normalised": "    print(f\"Starting normalization for '{input_data_folder}' into '{output_normalized_folder}'...\")"}
{"unnormalised": "", "normalised": "    process_folder(input_data_folder, output_normalized_folder)"}
{"unnormalised": "", "normalised": "    print(\"Normalization complete.\")"}
{"unnormalised": "", "normalised": "    # --- Verification ---"}
{"unnormalised": "", "normalised": "    print(\"\\n--- Verifying a sample normalized file ---\")"}
{"unnormalised": "", "normalised": "    try:"}
{"unnormalised": "", "normalised": "        with open(os.path.join(output_normalized_folder, \"test1.txt\"), 'r', encoding='utf-8') as f:"}
{"unnormalised": "", "normalised": "            print(f.read())"}
{"unnormalised": "", "normalised": "    except FileNotFoundError:"}
{"unnormalised": "", "normalised": "        print(\"Sample normalized file 'test1.txt' not found in output folder.\")"}
{"unnormalised": "", "normalised": "```"}
{"unnormalised": "", "normalised": "**व्याख्या आ डिजाइन विकल्प:**"}
{"unnormalised": "", "normalised": "1.  **`num2words` लाइब्रेरी:** ई प्राकृतिक संख्या परिवर्तनक लेल एकटा महत्वपूर्ण निर्भरता अछि। एकरा स्थापित करए कें सुनिश्चित करू: `pip install num2words`।"}
{"unnormalised": "", "normalised": "2.  **संचालनक क्रम:** `re.sub` कॉल क क्रम महत्वपूर्ण अछि।"}
{"unnormalised": "", "normalised": "    *   **पहिलाँ विशिष्ट प्रतीक:** सही प्रतिस्थापन सुनिश्चित करबाक लेल `@`, `&` जेहन सामान्य प्रतीकसँ पहिने `+/-`, `!=`, `<=`, `>=` कें संभालल जाइत अछि।"}
{"unnormalised": "", "normalised": "    *   **`/` हैंडलिंग:** `/` प्रतीकमे जटिल नियम छै। एकरा एकटा विशिष्ट क्रममे संभालल जाइत अछि: एकमक साथ अंश, फेर सामान्य अंश, फेर शब्दक बीच \"या\", फेर मिश्रित मामलाक लेल \"स्लैश\"। ई झरना सुनिश्चित करैत अछि जे सभसँ उपयुक्त अर्थ लागू कएल जाए।"}
{"unnormalised": "", "normalised": "    *   **तिथियाँ:** `DD/MM/YYYY` कें अंश या मात्र संख्याक रूपमे व्याख्या करए सँ बचबाक लेल जल्दी संसाधित।"}
{"unnormalised": "", "normalised": "    *   **मुद्रा + संख्या + प्रत्यय:** ई एकटा बहुत विशिष्ट पैटर्न अछि, एहि लेल एकरा जल्दी संभालल जाएत अछि।"}
{"unnormalised": "", "normalised": "    *   **संख्यात्मक प्रत्यय:** सामान्य संख्या रूपांतरणसँ पहिने संभालल गेल। `20K` कें `twenty K` आ फेर `twenty thousand` नहि बनबाक चाही।"}
{"unnormalised": "", "normalised": "    *   **एकम:** सामान्य संख्या रूपांतरणसँ पहिने संभालल गेल। `10cm` कें `ten cm` फेर `ten centimeter` नहि बनबाक चाही।"}
{"unnormalised": "", "normalised": "    *   **संक्षिप्तीकरण:** गलत व्याख्यासँ बचबाक लेल विशेष उपसर्गक बाद आ सामान्य संख्यासँ पहिने संभालल जाइत अछि। बहिष्कार महत्वपूर्ण अछि।"}
{"unnormalised": "", "normalised": "    *   **सामान्य संख्या:** अपेक्षाकृत बादमे लागू कएल गेल जे कोनो शेष अंक कें पकड़े जे अधिक विशिष्ट नियम द्वारा कवर नहि कएल गेल अछि।"}
{"unnormalised": "", "normalised": "    *   **गणितीय संकेतन:** अंतमे लागू कएल गेल, किएक तँ बहुतो गणितीय घटक (जेना `^`, `_`, `∫`, `Σ`, संख्या) कें पहिने प्रतीक या संख्या नियम द्वारा स्पर्श कएल जा सकैत अछि। फेर गणित-विशिष्ट regex ओकरा कथित रूपमे बाँधैत अछि।"}
{"unnormalised": "", "normalised": "3.  **नियमित अभिव्यक्ति:**"}
{"unnormalised": "", "normalised": "    *   `\\b`: शब्द सीमा कें व्यापक रूपसँ पूरा शब्द/संख्या कें मिलान करबाक आ अन्य शब्द या पहिचानकर्ताक भीतर आंशिक प्रतिस्थापनसँ बचबाक लेल उपयोग कएल जाएत अछि।"}
{"unnormalised": "", "normalised": "    *   `(?:\\.\\d+)?`: संख्यामे वैकल्पिक दशमलव भागक लेल गैर-कैप्चरिंग समूह (उदाहरणक लेल, `10` या `10.5`)।"}
{"unnormalised": "", "normalised": "    *   `re.IGNORECASE`: `KG`, `kg`, आदिकें पकड़बाक लेल एकम मिलानक लेल उपयोग कएल जाएत अछि।"}
{"unnormalised": "", "normalised": "4.  **`convert_number_to_words` सहायक:** `num2words` कें लपेटैत अछि आ सुनिश्चित करबाक लेल दशमलव संख्याक लेल एकटा साधारण जाँच जोड़ैत अछि जे ओकरा शालीनतासँ संभालल जाए (उदाहरणक लेल, `12.5` `twelve point five` बनि जाएत अछि)। ई ओ मामलाकें सेहो संभालैत अछि जतए `1.0` या `1.00` कें बस \"एक\" होएबाक चाही \"एक बिंदु शून्य\" नहि।"}
{"unnormalised": "", "normalised": "5.  **क्रमवाचक संख्या:** तिथि रूपांतरणक लेल `num2words(day, to='ordinal')` क उपयोग कएल जाएत अछि, ई सुनिश्चित करैत अछि जे \"दसवाँ\", \"पहिला\", आदि।"}
{"unnormalised": "", "normalised": "6.  **त्रुटि हैंडलिंग:** फाइल प्रोसेसिंगक दौरान संभावित `IOError` या अन्य समस्याकें पकड़बाक लेल फाइल प्रोसेसिंगक दौरान `try-except` ब्लॉक शामिल कएल गेल अछि, समस्याग्रस्त फाइल कें लॉग करए, आ एहन मामलामे मूल कें कॉपी करए।"}
{"unnormalised": "", "normalised": "7.  **`unicodedata`:** जखन कि एहि संस्करणमे `normalize_text` कें लेल स्पष्ट रूपसँ उपयोग नहि कएल गेल (किएक तँ `re` एकरा अधिकांश कें संभालैत अछि, आ `unicodedata` पाठ मानकीकरणक लेल अधिक अछि), जँ आवश्यक होए तँ अधिक उन्नत प्रतीक हैंडलिंगक लेल ध्यानमे रखएकेँ ई एकटा नीक उपकरण अछि।"}
{"unnormalised": "", "normalised": "8.  **आउटपुट फोल्डर मिररिंग:** `os.makedirs(output_folder, exist_ok=True)` आ `os."}
