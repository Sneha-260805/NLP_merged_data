{"unnormalised": "डॉ. का उपयोग चिकित्सा पेशेवरों के लिए और प्रो. का उपयोग प्रोफेसरों के लिए करना याद रखें। भारत में कानूनी संदर्भों में वकीलों के लिए \"Adv.\" का उपयोग देखना भी आम है।", "normalised": "ठीक है, मैं व्यापक सामान्यीकरण नियमों और \"Dr.\", \"Prof.\" और \"Adv.\" के विशिष्ट संचालन को समझता हूँ। मैं इन आवश्यकताओं के अनुसार पाठ्य डेटा को संसाधित करने के लिए एक पायथन स्क्रिप्ट लागू करूंगा।"}
{"unnormalised": "", "normalised": "यहाँ एक विवरण दिया गया है कि स्क्रिप्ट प्रत्येक नियम को कैसे संबोधित करेगी, जिसके बाद पायथन कोड होगा:"}
{"unnormalised": "", "normalised": "**मुख्य तर्क और दृष्टिकोण:**"}
{"unnormalised": "", "normalised": "1.  **फ़ाइल सिस्टम ट्रेवर्सल:** मैं इनपुट निर्देशिका में सभी फ़ोल्डरों और फ़ाइलों में पुनरावर्ती रूप से जाने के लिए `os.walk` का उपयोग करूँगा।"}
{"unnormalised": "", "normalised": "2.  **आउटपुट निर्देशिका मिररिंग:** इनपुट में प्रत्येक फ़ोल्डर के लिए, मैं `dataset_normalized` आउटपुट निर्देशिका में एक संगत फ़ोल्डर बनाऊँगा।"}
{"unnormalised": "", "normalised": "3.  **फ़ाइल प्रोसेसिंग:**"}
{"unnormalised": "", "normalised": "    *   यदि कोई फ़ाइल `.txt` फ़ाइल है, तो इसकी सामग्री को पढ़ा, सामान्यीकृत किया जाएगा और फिर मिरर किए गए आउटपुट फ़ोल्डर में एक नई `.txt` फ़ाइल में लिखा जाएगा।"}
{"unnormalised": "", "normalised": "    *   यदि कोई फ़ाइल `.txt` फ़ाइल नहीं है, तो इसे बिना किसी संशोधन के सीधे मिरर किए गए आउटपुट फ़ोल्डर में कॉपी किया जाएगा।"}
{"unnormalised": "", "normalised": "4.  **सामान्यीकरण क्रम (सही आउटपुट के लिए महत्वपूर्ण):** सामान्यीकरण नियमों को लागू करने का क्रम मायने रखता है। मैं आम तौर पर अधिक सामान्य नियमों से पहले अधिक विशिष्ट नियम लागू करूँगा (उदाहरण के लिए, सामान्य संख्याओं से पहले मुद्रा + संख्या + प्रत्यय, या सामान्य अक्षरांकीय पैटर्न से पहले विशिष्ट प्रतीक)।"}
{"unnormalised": "", "normalised": "    *   प्रतीक और विशेष वर्ण।"}
{"unnormalised": "", "normalised": "    *   मुद्रा + संख्या + प्रत्यय।"}
{"unnormalised": "", "normalised": "    *   तिथियां।"}
{"unnormalised": "", "normalised": "    *   संख्याएँ (इकाइयों में शामिल हैं, लेकिन इकाई विस्तार स्वयं बाद में आता है)।"}
{"unnormalised": "", "normalised": "    *   संक्षिप्त रूप।"}
{"unnormalised": "", "normalised": "    *   इकाइयाँ।"}
{"unnormalised": "", "normalised": "    *   गणितीय नोटेशन।"}
{"unnormalised": "", "normalised": "    *   \"Dr.\", \"Prof.\", \"Adv.\" जैसे विशेष उपसर्गों को संख्या या संक्षिप्त रूप नियमों द्वारा गलत व्याख्या से बचने के लिए जल्दी या विशिष्ट regex के साथ संभाला जाएगा।"}
{"unnormalised": "", "normalised": "    *   सामान्य `/` संचालन।"}
{"unnormalised": "", "normalised": "    *   अंतिम चरण के रूप में स्पेस सामान्यीकरण।"}
{"unnormalised": "", "normalised": "**विस्तृत नियम कार्यान्वयन रणनीति:**"}
{"unnormalised": "", "normalised": "1.  **प्रतीक → कथित रूप:** मैं सामान्य प्रतीकों को उनके कथित रूपों में मैप करने वाले एक शब्दकोश का उपयोग करूँगा और पाठ के माध्यम से पुनरावृति करूँगा, प्रतिस्थापन करूँगा। नियमित अभिव्यक्तियों का उपयोग उन प्रतीकों के लिए किया जाएगा जो अलग-अलग संदर्भों के साथ दिखाई दे सकते हैं (उदाहरण के लिए, `+/-`)।"}
{"unnormalised": "", "normalised": "    *   `art/craft` -> `art or craft` (regex: `(\\b\\w+)\\/(\\w+\\b)`)"}
{"unnormalised": "", "normalised": "    *   `QA/Dev` -> `Q-A slash D-e-v` (मिश्रित मामले या संक्षिप्तीकरण के लिए regex `(\\b[A-Z0-9]+)\\/([A-Z0-9]+\\b)`)"}
{"unnormalised": "", "normalised": "    *   `2+2=4` को गणितीय नोटेशन नियम द्वारा संभाला जाएगा।"}
{"unnormalised": "", "normalised": "    *   `$`, `~`, `*`, `#`, `@`, `&`, आदि को सीधे मैप किया जाएगा।"}
{"unnormalised": "", "normalised": "2.  **संक्षिप्त रूप → हाइफ़नयुक्त अक्षर:**"}
{"unnormalised": "", "normalised": "    *   Regex: `\\b[A-Z]{2,}\\b` (दो या अधिक लगातार बड़े अक्षर, पूरे शब्द के रूप में)। मुझे सावधान रहने की आवश्यकता है कि इसे `Dr.`, `Prof.`, `Adv.` पर लागू न करें।"}
{"unnormalised": "", "normalised": "    *   `'-'.join(match.group())` से बदलें।"}
{"unnormalised": "", "normalised": "3.  **संख्याएँ → कथित रूप:** यह जटिल है। मैं सामान्य संख्या रूपांतरण के लिए `num2words` लाइब्रेरी का उपयोग करूँगा, जो विभिन्न संदर्भों को संभालती है। \"आधा किलोग्राम\" जैसे विशिष्ट मामलों के लिए, मैं `(\\d+)/(\\d+)\\s*(\\w+)` जैसे पैटर्न की पहचान करने के लिए regex का उपयोग करूँगा, जिसके बाद एक इकाई होगी, और भिन्न पर `num2words` लागू करूँगा या `1/2` को \"आधा\" में बदलूँगा।"}
{"unnormalised": "", "normalised": "    *   सामान्य संख्याएँ: `num2words(number)`"}
{"unnormalised": "", "normalised": "    *   भिन्‍न: `1/2 kg` -> `half kilogram`, `3/4` -> `three divided by four` (गणित द्वारा संभाला गया, लेकिन तिथियों के साथ भ्रमित न होने के लिए सावधान रहने की आवश्यकता है)।"}
{"unnormalised": "", "normalised": "4.  **संख्यात्मक प्रत्यय → विस्तारित रूप:**"}
{"unnormalised": "", "normalised": "    *   Regex: `(\\d+)([KMBT])\\b`"}
{"unnormalised": "", "normalised": "    *   `K` को `thousand`, `M` को `million`, `B` को `billion`, `T` को `trillion` पर मैप करें।"}
{"unnormalised": "", "normalised": "    *   `num2words` का उपयोग करके संख्या भाग को रूपांतरित करें।"}
{"unnormalised": "", "normalised": "5.  **मुद्रा + संख्या + प्रत्यय:**"}
{"unnormalised": "", "normalised": "    *   Regex: `([$₹€£])(\\s*)(\\d+)([KMBT])?\\b`"}
{"unnormalised": "", "normalised": "    *   मुद्रा प्रतीक, संख्या और प्रत्यय को रूपांतरित करें।"}
{"unnormalised": "", "normalised": "6.  **तिथियाँ → प्राकृतिक कथित रूप:**"}
{"unnormalised": "", "normalised": "    *   `DD-MM-YYYY`, `DD/MM/YYYY`, `YYYY-MM-DD` के लिए Regex पैटर्न।"}
{"unnormalised": "", "normalised": "    *   पार्स करने के लिए `datetime.strptime` और फिर क्रमिक संख्याओं (उदाहरण के लिए, \"tenth\", \"first\") और कथित वर्ष के लिए कस्टम लॉजिक के साथ `strftime` का उपयोग करें। अस्पष्ट `DD/MM/YYYY` के लिए `DD/MM/YYYY` को डिफ़ॉल्ट मानते हुए।"}
{"unnormalised": "", "normalised": "7.  **इकाइयाँ → कथित रूप:**"}
{"unnormalised": "", "normalised": "    *   `(\\d+)(\\s*)(cm|mm|m|km|g|kg|mg|ml|l|°C|...)` खोजने के लिए Regex"}
{"unnormalised": "", "normalised": "    *   इकाइयों को पूर्ण शब्दों में मैप करें (उदाहरण के लिए, `cm` को `centimeter`, `°C` को `degree celsius`)।"}
{"unnormalised": "", "normalised": "    *   पिछली संख्या में संख्या रूपांतरण लागू करें।"}
{"unnormalised": "", "normalised": "8.  **गणितीय नोटेशन → कथित रूप:** इसके लिए regex के एक परिष्कृत सेट और संभावित रूप से अधिक जटिल अभिव्यक्तियों के लिए एक छोटे पार्सर की आवश्यकता होती है।"}
{"unnormalised": "", "normalised": "    *   `x^2`: `x squared` (regex `(\\w)\\^2`)"}
{"unnormalised": "", "normalised": "    *   `x^3`: `x cubed` (regex `(\\w)\\^3`)"}
{"unnormalised": "", "normalised": "    *   `x^n`: `x to the power of n` (regex `(\\w)\\^(\\w+)`)"}
{"unnormalised": "", "normalised": "    *   `x_i`: `x sub i` (regex `(\\w)_(\\w+)`)"}
{"unnormalised": "", "normalised": "    *   `√x`: `square root of x` (regex `√(\\w+)`)"}
{"unnormalised": "", "normalised": "    *   `∫`: `integral`"}
{"unnormalised": "", "normalised": "    *   `Σ`: `summation`"}
{"unnormalised": "", "normalised": "    *   भिन्‍न: `3/4` -> `three divided by four` (regex: `(\\d+)\\/(\\d+)`, लेकिन यह सुनिश्चित करना कि यह कोई तिथि नहीं है)।"}
{"unnormalised": "", "normalised": "    *   प्रतीक: `≠`, `≤`, `≥` को सामान्य प्रतीक प्रतिस्थापन द्वारा संभाला जाएगा।"}
{"unnormalised": "", "normalised": "9.  **आउटपुट प्रारूप:**"}
{"unnormalised": "", "normalised": "    *   अंत में स्पेस को सामान्य करें: `re.sub(r'\\s+', ' ', text).strip()`।"}
{"unnormalised": "", "normalised": "10. **फ़ाइल हैंडलिंग:** `os.walk`, `os.makedirs`, `shutil.copy2`।"}
{"unnormalised": "", "normalised": "**विशिष्ट उपसर्ग संचालन:**"}
{"unnormalised": "", "normalised": "*   `Dr.`, `Prof.`, `Adv.` को इन सटीक स्ट्रिंग्स की तलाश करके संभाला जाएगा, संभवतः एक अवधि या स्पेस के बाद, और उन्हें संरक्षित किया जाएगा। यह सामान्य संक्षिप्त रूप प्रसंस्करण से पहले होना चाहिए।"}
{"unnormalised": "", "normalised": "आइए पायथन स्क्रिप्ट बनाना शुरू करें।"}
{"unnormalised": "", "normalised": "```python"}
{"unnormalised": "", "normalised": "import os"}
{"unnormalised": "", "normalised": "import re"}
{"unnormalised": "", "normalised": "import shutil"}
{"unnormalised": "", "normalised": "from datetime import datetime"}
{"unnormalised": "", "normalised": "from num2words import num2words"}
{"unnormalised": "", "normalised": "import unicodedata # For handling unicode symbols"}
{"unnormalised": "", "normalised": "def ordinal_suffix(day):"}
{"unnormalised": "", "normalised": "    \"\"\"Returns the ordinal suffix for a number.\"\"\""}
{"unnormalised": "", "normalised": "    if 10 <= day % 100 <= 20:"}
{"unnormalised": "", "normalised": "        return 'th'"}
{"unnormalised": "", "normalised": "    else:"}
{"unnormalised": "", "normalised": "        return {1: 'st', 2: 'nd', 3: 'rd'}.get(day % 10, 'th')"}
{"unnormalised": "", "normalised": "def convert_number_to_words(number_str):"}
{"unnormalised": "", "normalised": "    \"\"\"Converts a number string to its spoken form, handling edge cases.\"\"\""}
{"unnormalised": "", "normalised": "    try:"}
{"unnormalised": "", "normalised": "        if '.' in number_str:"}
{"unnormalised": "", "normalised": "            # Handle decimals separately if num2words doesn't do it naturally for all cases"}
{"unnormalised": "", "normalised": "            integer_part, decimal_part = number_str.split('.')"}
{"unnormalised": "", "normalised": "            integer_words = num2words(int(integer_part))"}
{"unnormalised": "", "normalised": "            decimal_words = 'point ' + ' '.join(num2words(int(d)) for d in decimal_part)"}
{"unnormalised": "", "normalised": "            return f\"{integer_words} {decimal_words}\""}
{"unnormalised": "", "normalised": "        else:"}
{"unnormalised": "", "normalised": "            return num2words(int(number_str))"}
{"unnormalised": "", "normalised": "    except ValueError:"}
{"unnormalised": "", "normalised": "        return number_str # Return original if conversion fails"}
{"unnormalised": "", "normalised": "def normalize_text(text):"}
{"unnormalised": "", "normalised": "    \"\"\""}
{"unnormalised": "", "normalised": "    Applies all normalization rules to the input text."}
{"unnormalised": "", "normalised": "    \"\"\""}
{"unnormalised": "", "normalised": "    # --- 0. Special Prefix Handling (Dr., Prof., Adv.) ---"}
{"unnormalised": "", "normalised": "    # These are handled by keeping them as is, they should not be treated as acronyms."}
{"unnormalised": "", "normalised": "    # No explicit replacement needed, just ensures other rules don't modify them."}
{"unnormalised": "", "normalised": "    # --- 1. Symbols → Spoken form ---"}
{"unnormalised": "", "normalised": "    # More specific symbol replacements first"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\+/-', 'plus or minus', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'!=', 'not equal to', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'<=', 'less than or equal to', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'>=', 'greater than or equal to', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'==', 'equals', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'->', 'maps to', text) # Common in math/programming context"}
{"unnormalised": "", "normalised": "    symbol_map = {"}
{"unnormalised": "", "normalised": "        '#': 'hash',"}
{"unnormalised": "", "normalised": "        '@': 'at',"}
{"unnormalised": "", "normalised": "        '&': 'and',"}
{"unnormalised": "", "normalised": "        '*': 'asterisk',"}
{"unnormalised": "", "normalised": "        '~': 'approximately',"}
{"unnormalised": "", "normalised": "        '≠': 'not equal to',"}
{"unnormalised": "", "normalised": "        '≤': 'less than or equal to',"}
{"unnormalised": "", "normalised": "        '≥': 'greater than or equal to',"}
{"unnormalised": "", "normalised": "        '∫': 'integral',"}
{"unnormalised": "", "normalised": "        '∑': 'summation',"}
{"unnormalised": "", "normalised": "        'π': 'pi',"}
{"unnormalised": "", "normalised": "        '√': 'square root of',"}
{"unnormalised": "", "normalised": "        '%': 'percent', # After ~ approximately, before general numbers"}
{"unnormalised": "", "normalised": "        '°': 'degree', # Before general numbers"}
{"unnormalised": "", "normalised": "        '€': 'euro',"}
{"unnormalised": "", "normalised": "        '£': 'pound',"}
{"unnormalised": "", "normalised": "    }"}
{"unnormalised": "", "normalised": "    # Sort keys by length in descending order to avoid partial matches (e.g., '≠' before '≠')"}
{"unnormalised": "", "normalised": "    for symbol, spoken_form in sorted(symbol_map.items(), key=lambda item: len(item[0]), reverse=True):"}
{"unnormalised": "", "normalised": "        text = text.replace(symbol, spoken_form)"}
{"unnormalised": "", "normalised": "    # Handling '/'"}
{"unnormalised": "", "normalised": "    # Priority:"}
{"unnormalised": "", "normalised": "    # 1. Divided by (between numbers/math)"}
{"unnormalised": "", "normalised": "    # 2. Or (between words)"}
{"unnormalised": "", "normalised": "    # 3. Slash (mixed cases, abbreviations, remaining)"}
{"unnormalised": "", "normalised": "    # 1. Fractions or division in math: 3/4 -> three divided by four, 1/2 -> one divided by two"}
{"unnormalised": "", "normalised": "    # This needs to be robust, ensuring it's not a date."}
{"unnormalised": "", "normalised": "    # Specific for 1/2 as \"half\" when followed by a unit (Rule 3/7 interplay)"}
{"unnormalised": "", "normalised": "    def replace_fraction_with_unit(match):"}
{"unnormalised": "", "normalised": "        num_str = match.group(1)"}
{"unnormalised": "", "normalised": "        denom_str = match.group(2)"}
{"unnormalised": "", "normalised": "        unit = match.group(3) if match.group(3) else ''"}
{"unnormalised": "", "normalised": "        if num_str == '1' and denom_str == '2':"}
{"unnormalised": "", "normalised": "            return f\"half {unit}\""}
{"unnormalised": "", "normalised": "        else:"}
{"unnormalised": "", "normalised": "            return f\"{convert_number_to_words(num_str)} divided by {convert_number_to_words(denom_str)} {unit}\".strip()"}
{"unnormalised": "", "normalised": "    # Pattern for X/Y unit, e.g., 1/2 kg, 3/4 meter"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b(\\d+)/(\\d+)\\s*(cm|mm|m|km|g|kg|mg|ml|l|C|F|K|hour|day|week|month|year)s?\\b',"}
{"unnormalised": "", "normalised": "                  replace_fraction_with_unit, text, flags=re.IGNORECASE)"}
{"unnormalised": "", "normalised": "    # Pattern for X/Y without a specific unit, e.g., 3/4"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b(\\d+)/(\\d+)\\b',"}
{"unnormalised": "", "normalised": "                  lambda m: f\"{convert_number_to_words(m.group(1))} divided by {convert_number_to_words(m.group(2))}\","}
{"unnormalised": "", "normalised": "                  text)"}
{"unnormalised": "", "normalised": "    # 2. \"or\" between words (e.g., art/craft)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'(\\b\\w+)\\/(\\w+\\b)', r'\\1 or \\2', text)"}
{"unnormalised": "", "normalised": "    # 3. \"slash\" for mixed cases or abbreviations (e.g., QA/Dev, R/D)"}
{"unnormalised": "", "normalised": "    # This also catches any remaining slashes that aren't dates or fractions"}
{"unnormalised": "", "normalised": "    text = re.sub(r'([A-Za-z0-9]+)\\/([A-Za-z0-9]+)', r'\\1 slash \\2', text)"}
{"unnormalised": "", "normalised": "    # --- 2. Acronyms → Hyphenated letters ---"}
{"unnormalised": "", "normalised": "    # Exclude Dr., Prof., Adv. and common currency codes (e.g., USD, EUR, INR)"}
{"unnormalised": "", "normalised": "    # Also exclude single letters or numbers that might be part of an expression, and units."}
{"unnormalised": "", "normalised": "    # This regex is tricky. Let's try to match sequences of uppercase letters."}
{"unnormalised": "", "normalised": "    # Lookbehind for a word boundary, lookahead for a word boundary."}
{"unnormalised": "", "normalised": "    # Exclude common pre-defined terms."}
{"unnormalised": "", "normalised": "    excluded_acronyms = {'DR', 'PROF', 'ADV', 'USD', 'EUR', 'GBP', 'INR', 'K', 'M', 'B', 'T'}"}
{"unnormalised": "", "normalised": "    def replace_acronym(match):"}
{"unnormalised": "", "normalised": "        acronym = match.group(0)"}
{"unnormalised": "", "normalised": "        if acronym in excluded_acronyms:"}
{"unnormalised": "", "normalised": "            return acronym"}
{"unnormalised": "", "normalised": "        # Check if it's potentially a unit like 'KG', 'CM' etc. (already handled by units rule later)"}
{"unnormalised": "", "normalised": "        if len(acronym) <= 3 and acronym.lower() in ['cm', 'mm', 'm', 'km', 'g', 'kg', 'mg', 'ml', 'l', 'c', 'f', 'k']:"}
{"unnormalised": "", "normalised": "            return acronym # Let unit rule handle it"}
{"unnormalised": "", "normalised": "        return '-'.join(list(acronym))"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b[A-Z]{2,}\\b', replace_acronym, text)"}
{"unnormalised": "", "normalised": "    # --- 6. Dates → Natural spoken form ---"}
{"unnormalised": "", "normalised": "    # Prioritize YYYY-MM-DD"}
{"unnormalised": "", "normalised": "    def replace_date(match):"}
{"unnormalised": "", "normalised": "        try:"}
{"unnormalised": "", "normalised": "            date_obj = datetime.strptime(match.group(0), '%Y-%m-%d')"}
{"unnormalised": "", "normalised": "            day = date_obj.day"}
{"unnormalised": "", "normalised": "            month = date_obj.strftime('%B').lower()"}
{"unnormalised": "", "normalised": "            year = num2words(date_obj.year)"}
{"unnormalised": "", "normalised": "            return f\"{num2words(day, to='ordinal')} {month} {year}\""}
{"unnormalised": "", "normalised": "        except ValueError:"}
{"unnormalised": "", "normalised": "            return match.group(0) # Return original if parsing fails"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b\\d{4}-\\d{2}-\\d{2}\\b', replace_date, text)"}
{"unnormalised": "", "normalised": "    # Prioritize DD-MM-YYYY or DD/MM/YYYY (assuming DD/MM/YYYY when ambiguous)"}
{"unnormalised": "", "normalised": "    def replace_date_ambiguous(match):"}
{"unnormalised": "", "normalised": "        try:"}
{"unnormalised": "", "normalised": "            # Try DD/MM/YYYY first"}
{"unnormalised": "", "normalised": "            date_obj = datetime.strptime(match.group(0), '%d/%m/%Y')"}
{"unnormalised": "", "normalised": "        except ValueError:"}
{"unnormalised": "", "normalised": "            try:"}
{"unnormalised": "", "normalised": "                # Then try DD-MM-YYYY"}
{"unnormalised": "", "normalised": "                date_obj = datetime.strptime(match.group(0), '%d-%m-%Y')"}
{"unnormalised": "", "normalised": "            except ValueError:"}
{"unnormalised": "", "normalised": "                return match.group(0) # Return original if parsing fails"}
{"unnormalised": "", "normalised": "        day = date_obj.day"}
{"unnormalised": "", "normalised": "        month = date_obj.strftime('%B').lower()"}
{"unnormalised": "", "normalised": "        year = num2words(date_obj.year)"}
{"unnormalised": "", "normalised": "        return f\"{num2words(day, to='ordinal')} {month} {year}\""}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b\\d{2}[-/]\\d{2}[-/]\\d{4}\\b', replace_date_ambiguous, text)"}
{"unnormalised": "", "normalised": "    # --- 5. Currency + Number + Suffix ---"}
{"unnormalised": "", "normalised": "    # This must come before general numeric suffix and general number conversion."}
{"unnormalised": "", "normalised": "    def replace_currency_suffix(match):"}
{"unnormalised": "", "normalised": "        currency_symbol = match.group(1)"}
{"unnormalised": "", "normalised": "        number_str = match.group(3)"}
{"unnormalised": "", "normalised": "        suffix = match.group(4)"}
{"unnormalised": "", "normalised": "        "}
{"unnormalised": "", "normalised": "        currency_name = ''"}
{"unnormalised": "", "normalised": "        if currency_symbol == '$':"}
{"unnormalised": "", "normalised": "            currency_name = 'dollar'"}
{"unnormalised": "", "normalised": "        elif currency_symbol == '₹':"}
{"unnormalised": "", "normalised": "            currency_name = 'rupee'"}
{"unnormalised": "", "normalised": "        # Add other currencies if needed"}
{"unnormalised": "", "normalised": "        spoken_number = convert_number_to_words(number_str)"}
{"unnormalised": "", "normalised": "        if suffix:"}
{"unnormalised": "", "normalised": "            suffix_map = {'K': 'thousand', 'M': 'million', 'B': 'billion', 'T': 'trillion'}"}
{"unnormalised": "", "normalised": "            return f\"{currency_name} {spoken_number} {suffix_map[suffix]}\""}
{"unnormalised": "", "normalised": "        else:"}
{"unnormalised": "", "normalised": "            return f\"{currency_name} {spoken_number}\""}
{"unnormalised": "", "normalised": "    text = re.sub(r'([$₹€£])(\\s*)(\\d+)([KMBT])?\\b', replace_currency_suffix, text)"}
{"unnormalised": "", "normalised": "    # --- 4. Numeric suffixes → Expanded form ---"}
{"unnormalised": "", "normalised": "    # This must come before general number conversion."}
{"unnormalised": "", "normalised": "    def replace_numeric_suffix(match):"}
{"unnormalised": "", "normalised": "        number_str = match.group(1)"}
{"unnormalised": "", "normalised": "        suffix = match.group(2)"}
{"unnormalised": "", "normalised": "        spoken_number = convert_number_to_words(number_str)"}
{"unnormalised": "", "normalised": "        "}
{"unnormalised": "", "normalised": "        suffix_map = {'K': 'thousand', 'M': 'million', 'B': 'billion', 'T': 'trillion'}"}
{"unnormalised": "", "normalised": "        return f\"{spoken_number} {suffix_map[suffix]}\""}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b(\\d+)([KMBT])\\b', replace_numeric_suffix, text)"}
{"unnormalised": "", "normalised": "    # --- 7. Units → Spoken form ---"}
{"unnormalised": "", "normalised": "    # This must come before general number conversion."}
{"unnormalised": "", "normalised": "    unit_map = {"}
{"unnormalised": "", "normalised": "        'cm': 'centimeter', 'mm': 'millimeter', 'm': 'meter', 'km': 'kilometer',"}
{"unnormalised": "", "normalised": "        'g': 'gram', 'kg': 'kilogram', 'mg': 'milligram',"}
{"unnormalised": "", "normalised": "        'ml': 'milliliter', 'l': 'liter',"}
{"unnormalised": "", "normalised": "        'C': 'celsius', 'F': 'fahrenheit', 'K': 'kelvin', # For degree units"}
{"unnormalised": "", "normalised": "        'hrs': 'hours', 'hr': 'hour',"}
{"unnormalised": "", "normalised": "        'min': 'minute', 'mins': 'minutes',"}
{"unnormalised": "", "normalised": "        'sec': 'second', 'secs': 'seconds',"}
{"unnormalised": "", "normalised": "        'volt': 'volt', 'volts': 'volts', 'v': 'volt',"}
{"unnormalised": "", "normalised": "        'amp': 'ampere', 'amps': 'amperes', 'a': 'ampere',"}
{"unnormalised": "", "normalised": "        'watt': 'watt', 'watts': 'watts', 'w': 'watt',"}
{"unnormalised": "", "normalised": "        'hz': 'hertz', 'khz': 'kilohertz', 'mhz': 'megahertz', 'ghz': 'gigahertz'"}
{"unnormalised": "", "normalised": "    }"}
{"unnormalised": "", "normalised": "    def replace_unit(match):"}
{"unnormalised": "", "normalised": "        number_str = match.group(1)"}
{"unnormalised": "", "normalised": "        unit = match.group(2).lower()"}
{"unnormalised": "", "normalised": "        spoken_number = convert_number_to_words(number_str)"}
{"unnormalised": "", "normalised": "        spoken_unit = unit_map.get(unit, unit)"}
{"unnormalised": "", "normalised": "        # Handle plurals for units"}
{"unnormalised": "", "normalised": "        if int(number_str) > 1 and not spoken_unit.endswith('s') and spoken_unit not in ['celsius', 'fahrenheit', 'kelvin']:"}
{"unnormalised": "", "normalised": "            spoken_unit += 's'"}
{"unnormalised": "", "normalised": "        elif int(number_str) == 1 and spoken_unit.endswith('s') and spoken_unit not in ['celsius', 'fahrenheit', 'kelvin']:"}
{"unnormalised": "", "normalised": "            spoken_unit = spoken_unit[:-1] # Remove 's' if number is 1 and unit is plural"}
{"unnormalised": "", "normalised": "        return f\"{spoken_number} {spoken_unit}\""}
{"unnormalised": "", "normalised": "    # Pattern for numbers directly followed by a unit (e.g., 10cm, 5kg)"}
{"unnormalised": "", "normalised": "    # Using \\b for units to avoid partial matches (e.g., 'm' in 'meter')"}
{"unnormalised": "", "normalised": "    unit_pattern = r'\\b(\\d+(?:\\.\\d+)?)\\s*(%s)\\b' % '|'.join(re.escape(u) for u in unit_map.keys())"}
{"unnormalised": "", "normalised": "    text = re.sub(unit_pattern, replace_unit, text, flags=re.IGNORECASE)"}
{"unnormalised": "", "normalised": "    # Handle degrees Celsius/Fahrenheit specifically, often written as 25°C"}
{"unnormalised": "", "normalised": "    def replace_degree_unit(match):"}
{"unnormalised": "", "normalised": "        number_str = match.group(1)"}
{"unnormalised": "", "normalised": "        unit = match.group(2).upper() # 'C', 'F'"}
{"unnormalised": "", "normalised": "        spoken_number = convert_number_to_words(number_str)"}
{"unnormalised": "", "normalised": "        unit_name = 'celsius' if unit == 'C' else 'fahrenheit' if unit == 'F' else 'kelvin' if unit == 'K' else ''"}
{"unnormalised": "", "normalised": "        return f\"{spoken_number} degree {unit_name}\""}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b(\\d+(?:\\.\\d+)?)\\s*degree\\s*([CFK])\\b', replace_degree_unit, text, flags=re.IGNORECASE) # After 'degree' symbol is replaced"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b(\\d+(?:\\.\\d+)?)\\s*degree\\s*(celsius|fahrenheit|kelvin)\\b', lambda m: f\"{convert_number_to_words(m.group(1))} degree {m.group(2)}\", text, flags=re.IGNORECASE)"}
{"unnormalised": "", "normalised": "    # --- 3. Numbers → Spoken form (general) ---"}
{"unnormalised": "", "normalised": "    # Apply to any remaining standalone numbers. This should be late."}
{"unnormalised": "", "normalised": "    # Exclude numbers that are part of file names or mixed alphanumeric strings that don't look like numbers."}
{"unnormalised": "", "normalised": "    def replace_general_number(match):"}
{"unnormalised": "", "normalised": "        number_str = match.group(0)"}
{"unnormalised": "", "normalised": "        # Avoid converting numbers that are part of other identifiers (e.g., H2O, ID123)"}
{"unnormalised": "", "normalised": "        if re.match(r'^[A-Za-z]+$', number_str): # If it's pure alphabet, ignore"}
{"unnormalised": "", "normalised": "            return number_str"}
{"unnormalised": "", "normalised": "        "}
{"unnormalised": "", "normalised": "        # Avoid converting if it's a floating point number with only zero after decimal and num2words gives full stop"}
{"unnormalised": "", "normalised": "        if '.' in number_str and float(number_str) == int(float(number_str)):"}
{"unnormalised": "", "normalised": "            return convert_number_to_words(str(int(float(number_str))))"}
{"unnormalised": "", "normalised": "            "}
{"unnormalised": "", "normalised": "        return convert_number_to_words(number_str)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\b\\d+(?:\\.\\d+)?\\b', replace_general_number, text)"}
{"unnormalised": "", "normalised": "    # --- 8. Mathematical notation → Spoken form ---"}
{"unnormalised": "", "normalised": "    # Ensure this happens after general symbol/number conversions to avoid conflicts"}
{"unnormalised": "", "normalised": "    text = re.sub(r'(\\w)\\^2', r'\\1 squared', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'(\\w)\\^3', r'\\1 cubed', text)"}
{"unnormalised": "", "normalised": "    text = re.sub(r'(\\w)\\^(\\w+)', r'\\1 to the power of \\2', text) # General power"}
{"unnormalised": "", "normalised": "    text = re.sub(r'(\\w)_(\\w+)', r'\\1 sub \\2', text) # Subscript"}
{"unnormalised": "", "normalised": "    text = re.sub(r'summation\\s*x\\s*sub\\s*i', 'summation of x sub i', text) # Common summation form"}
{"unnormalised": "", "normalised": "    text = re.sub(r'integral\\s*(\\d+)\\s*to\\s*(\\d+)\\s*of\\s*(\\w)\\s*d\\s*(\\w)',"}
{"unnormalised": "", "normalised": "                  lambda m: f\"integral from {convert_number_to_words(m.group(1))} to {convert_number_to_words(m.group(2))} of {m.group(3)} d {m.group(4)}\","}
{"unnormalised": "", "normalised": "                  text) # Specific integral form ∫ 0→1 x dx"}
{"unnormalised": "", "normalised": "    text = re.sub(r'integral\\s*(\\w)\\s*d\\s*(\\w)', r'integral of \\1 d \\2', text) # General integral form ∫ x dx"}
{"unnormalised": "", "normalised": "    # --- Final Space Normalization ---"}
{"unnormalised": "", "normalised": "    text = re.sub(r'\\s+', ' ', text).strip()"}
{"unnormalised": "", "normalised": "    return text"}
{"unnormalised": "", "normalised": "def process_folder(input_folder, output_folder):"}
{"unnormalised": "", "normalised": "    \"\"\""}
{"unnormalised": "", "normalised": "    Walks through the input folder, normalizes .txt files, and copies others."}
{"unnormalised": "", "normalised": "    \"\"\""}
{"unnormalised": "", "normalised": "    os.makedirs(output_folder, exist_ok=True)"}
{"unnormalised": "", "normalised": "    unnormalized_txt_files = []"}
{"unnormalised": "", "normalised": "    for root, dirs, files in os.walk(input_folder):"}
{"unnormalised": "", "normalised": "        relative_path = os.path.relpath(root, input_folder)"}
{"unnormalised": "", "normalised": "        current_output_dir = os.path.join(output_folder, relative_path)"}
{"unnormalised": "", "normalised": "        os.makedirs(current_output_dir, exist_ok=True)"}
{"unnormalised": "", "normalised": "        for file_name in files:"}
{"unnormalised": "", "normalised": "            input_file_path = os.path.join(root, file_name)"}
{"unnormalised": "", "normalised": "            output_file_path = os.path.join(current_output_dir, file_name)"}
{"unnormalised": "", "normalised": "            if file_name.lower().endswith('.txt'):"}
{"unnormalised": "", "normalised": "                try:"}
{"unnormalised": "", "normalised": "                    with open(input_file_path, 'r', encoding='utf-8') as f_in:"}
{"unnormalised": "", "normalised": "                        content = f_in.read()"}
{"unnormalised": "", "normalised": "                    "}
{"unnormalised": "", "normalised": "                    normalized_content = normalize_text(content)"}
{"unnormalised": "", "normalised": "                    with open(output_file_path, 'w', encoding='utf-8') as f_out:"}
{"unnormalised": "", "normalised": "                        f_out.write(normalized_content)"}
{"unnormalised": "", "normalised": "                except Exception as e:"}
{"unnormalised": "", "normalised": "                    print(f\"Error processing {input_file_path}: {e}\")"}
{"unnormalised": "", "normalised": "                    unnormalized_txt_files.append(input_file_path)"}
{"unnormalised": "", "normalised": "                    # If error, copy the original file to output"}
{"unnormalised": "", "normalised": "                    shutil.copy2(input_file_path, output_file_path)"}
{"unnormalised": "", "normalised": "            else:"}
{"unnormalised": "", "normalised": "                shutil.copy2(input_file_path, output_file_path)"}
{"unnormalised": "", "normalised": "    "}
{"unnormalised": "", "normalised": "    if unnormalized_txt_files:"}
{"unnormalised": "", "normalised": "        print(\"\\n--- List of .txt files that could not be normalized (original copied instead) ---\")"}
{"unnormalised": "", "normalised": "        for f in unnormalized_txt_files:"}
{"unnormalised": "", "normalised": "            print(f)"}
{"unnormalised": "", "normalised": "if __name__ == \"__main__\":"}
{"unnormalised": "", "normalised": "    # Example usage:"}
{"unnormalised": "", "normalised": "    # Create a dummy dataset structure for testing"}
{"unnormalised": "", "normalised": "    if not os.path.exists(\"dataset\"):"}
{"unnormalised": "", "normalised": "        os.makedirs(\"dataset/subfolder1\", exist_ok=True)"}
{"unnormalised": "", "normalised": "        os.makedirs(\"dataset/subfolder2\", exist_ok=True)"}
{"unnormalised": "", "normalised": "        with open(\"dataset/test1.txt\", \"w\", encoding=\"utf-8\") as f:"}
{"unnormalised": "", "normalised": "            f.write(\"The price is $20B. NASA launched in 1958. Approx ~5% gain.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"Today's date is 10/09/2024. Dr. Smith works for the U.S.A. government.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"The temperature is 25°C. Water boiled at 100°C. Total 5km run.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"The equation is 2+2=4. Area is πr^2. Sum is Σ x_i. Consider x^2 and x^3. Also x^n.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"The fraction is 3/4. We need 1/2 kg of sugar. The report covers QA/Dev and art/craft. GDP growth is strong. Adv. Ram is here.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"Math: ∫ x^2 dx. Or ∫ 0→1 x dx. If x != y, then x <= z or z >= x. He runs 100M dash.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"He ran 10km in 45 min. His speed was 100km/hr. The battery is 12V and 50A.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"Product IDs: PROD123, PROD456.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"₹500M was invested. The value is 99. The number is 7.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"This has a decimal 12.5 kg. A total of 1.0 M people. Test 1.0 kg and 1.00 kg.\\n\")"}
{"unnormalised": "", "normalised": "        with open(\"dataset/subfolder1/test2.txt\", \"w\", encoding=\"utf-8\") as f:"}
{"unnormalised": "", "normalised": "            f.write(\"Project Alpha started 2023-12-01. Prof. Jones gave a lecture on ∫ x^n dx.\\n\")"}
{"unnormalised": "", "normalised": "            f.write(\"He spent 2.5 hrs studying. The data is 1.2M records. He earns 50K per month.\\n\")"}
{"unnormalised": "", "normalised": "        with open(\"dataset/subfolder2/image.jpg\", \"w\", encoding=\"utf-8\") as f:"}
{"unnormalised": "", "normalised": "            f.write(\"This is not a text file.\") # Dummy content for non-txt file"}
{"unnormalised": "", "normalised": "        with open(\"dataset/subfolder2/another.txt\", \"w\", encoding=\"utf-8\") as f:"}
{"unnormalised": "", "normalised": "            f.write(\"Special characters: ≠, ≤, ≥. Test approximately five percent ~5%. Hash #tag. At @user. And & more.\")"}
{"unnormalised": "", "normalised": "    input_data_folder = \"dataset\""}
{"unnormalised": "", "normalised": "    output_normalized_folder = \"dataset_normalized\""}
{"unnormalised": "", "normalised": "    print(f\"Starting normalization for '{input_data_folder}' into '{output_normalized_folder}'...\")"}
{"unnormalised": "", "normalised": "    process_folder(input_data_folder, output_normalized_folder)"}
{"unnormalised": "", "normalised": "    print(\"Normalization complete.\")"}
{"unnormalised": "", "normalised": "    # --- Verification ---"}
{"unnormalised": "", "normalised": "    print(\"\\n--- Verifying a sample normalized file ---\")"}
{"unnormalised": "", "normalised": "    try:"}
{"unnormalised": "", "normalised": "        with open(os.path.join(output_normalized_folder, \"test1.txt\"), 'r', encoding='utf-8') as f:"}
{"unnormalised": "", "normalised": "            print(f.read())"}
{"unnormalised": "", "normalised": "    except FileNotFoundError:"}
{"unnormalised": "", "normalised": "        print(\"Sample normalized file 'test1.txt' not found in output folder.\")"}
{"unnormalised": "", "normalised": "```"}
{"unnormalised": "", "normalised": "**स्पष्टीकरण और डिज़ाइन विकल्प:**"}
{"unnormalised": "", "normalised": "1.  **`num2words` लाइब्रेरी:** यह प्राकृतिक संख्या रूपांतरण के लिए एक महत्वपूर्ण निर्भरता है। सुनिश्चित करें कि आप इसे स्थापित करें: `pip install num2words`।"}
{"unnormalised": "", "normalised": "2.  **ऑपरेशनों का क्रम:** `re.sub` कॉलों का क्रम महत्वपूर्ण है।"}
{"unnormalised": "", "normalised": "    *   **विशिष्ट प्रतीक पहले:** `@`, `&` जैसे सामान्य प्रतीकों से पहले `+/-`, `!=`, `<=`, `>=` को सही प्रतिस्थापन सुनिश्चित करने के लिए संभाला जाता है।"}
{"unnormalised": "", "normalised": "    *   **`/` संचालन:** `/` प्रतीक में जटिल नियम हैं। इसे एक विशिष्ट क्रम में संभाला जाता है: इकाइयों के साथ भिन्‍न, फिर सामान्य भिन्‍न, फिर शब्दों के बीच \"या\", फिर मिश्रित मामलों के लिए \"स्लैश\"। यह कैस्केड सुनिश्चित करता है कि सबसे उपयुक्त अर्थ लागू किया जाए।"}
{"unnormalised": "", "normalised": "    *   **तिथियाँ:** `DD/MM/YYYY` को भिन्‍न या केवल संख्याओं के रूप में व्याख्या किए जाने से बचने के लिए जल्दी संसाधित किया जाता है।"}
{"unnormalised": "", "normalised": "    *   **मुद्रा + संख्या + प्रत्यय:** यह एक बहुत ही विशिष्ट पैटर्न है, इसलिए इसे जल्दी संभाला जाता है।"}
{"unnormalised": "", "normalised": "    *   **संख्यात्मक प्रत्यय:** सामान्य संख्या रूपांतरण से पहले संभाला जाता है। `20K` `twenty K` और फिर `twenty thousand` नहीं बनना चाहिए।"}
{"unnormalised": "", "normalised": "    *   **इकाइयाँ:** सामान्य संख्या रूपांतरण से पहले संभाला जाता है। `10cm` `ten cm` और फिर `ten centimeter` नहीं बनना चाहिए।"}
{"unnormalised": "", "normalised": "    *   **संक्षिप्त रूप:** विशेष उपसर्गों के बाद और सामान्य संख्याओं से पहले गलत व्याख्या से बचने के लिए संभाला जाता है। बहिष्करण महत्वपूर्ण हैं।"}
{"unnormalised": "", "normalised": "    *   **सामान्य संख्याएँ:** अपेक्षाकृत देर से लागू किया जाता है ताकि किसी भी शेष अंक को पकड़ा जा सके जो अधिक विशिष्ट नियमों द्वारा कवर नहीं किए गए हैं।"}
{"unnormalised": "", "normalised": "    *   **गणितीय नोटेशन:** अंत की ओर लागू किया जाता है, क्योंकि कई गणितीय घटक (जैसे `^`, `_`, `∫`, `Σ`, संख्याएँ) पहले के प्रतीक या संख्या नियमों से प्रभावित हो सकते हैं। फिर गणित-विशिष्ट regex उन्हें कथित रूपों में बांधता है।"}
{"unnormalised": "", "normalised": "3.  **नियमित अभिव्यक्तियाँ:**"}
{"unnormalised": "", "normalised": "    *   `\\b`: पूरे शब्दों/संख्याओं का मिलान करने और अन्य शब्दों या पहचानकर्ताओं के भीतर आंशिक प्रतिस्थापन से बचने के लिए शब्द सीमा का व्यापक रूप से उपयोग किया जाता है।"}
{"unnormalised": "", "normalised": "    *   `(?:\\.\\d+)?`: संख्याओं में वैकल्पिक दशमलव भागों के लिए गैर-कैप्चरिंग समूह (उदाहरण के लिए, `10` या `10.5`)।"}
{"unnormalised": "", "normalised": "    *   `re.IGNORECASE`: इकाइयों के मिलान के लिए उपयोग किया जाता है ताकि `KG`, `kg`, आदि को पकड़ा जा सके।"}
{"unnormalised": "", "normalised": "4.  **`convert_number_to_words` सहायक:** `num2words` को रैप करता है और यह सुनिश्चित करने के लिए दशमलव संख्याओं के लिए एक साधारण जाँच जोड़ता है कि उन्हें शालीनता से संभाला जाए (उदाहरण के लिए, `12.5` `twelve point five` बन जाता है)। यह उस स्थिति को भी संभालता है जहां `1.0` या `1.00` को केवल \"एक\" होना चाहिए न कि \"एक दशमलव शून्य\"।"}
{"unnormalised": "", "normalised": "5.  **क्रमसूचक संख्याएँ:** तिथि रूपांतरण के लिए `num2words(day, to='ordinal')` का उपयोग किया जाता है, जो \"tenth\", \"first\", आदि सुनिश्चित करता है।"}
{"unnormalised": "", "normalised": "6.  **त्रुटि प्रबंधन:** सामान्यीकरण के दौरान संभावित `IOError` या अन्य मुद्दों को पकड़ने, समस्याग्रस्त फ़ाइलों को लॉग करने और ऐसे मामलों में मूल की प्रतिलिपि बनाने के लिए फ़ाइल प्रसंस्करण के दौरान एक `try-except` ब्लॉक शामिल किया गया है।"}
{"unnormalised": "", "normalised": "7.  **`unicodedata`:** हालाँकि इस संस्करण में `normalize_text` के लिए स्पष्ट रूप से उपयोग नहीं किया गया है (क्योंकि `re` इसका अधिकांश भाग संभालता है, और `unicodedata` टेक्स्ट कैनोनाइजेशन के लिए अधिक है), यदि आवश्यक हो तो अधिक उन्नत प्रतीक संचालन के लिए ध्यान में रखने के लिए यह एक अच्छा उपकरण है।"}
{"unnormalised": "", "normalised": "8.  **आउटपुट फ़ोल्डर मिररिंग:** `os.makedirs(output_folder, exist_ok=True)` और `os.path.relpath` निर्देशिका संरचना का सही ढंग से पुनर्निर्माण करते हैं।"}
{"unnormalised": "", "normalised": "यह स्क्रिप्ट वर्णित सामान्यीकरण कार्यों को मजबूती से संभालनी चाहिए। विभिन्न इनपुट उदाहरणों के साथ इसका अच्छी तरह से परीक्षण करना याद रखें!"}
